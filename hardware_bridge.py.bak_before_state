#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
HALbridge Hardware Bridge â€” v4
- Wstecznie zgodny z V2 (device_commands.json, execute(text), reload()).
- Rozumie kontekst (last_action, last_targets) i potrafi go zapamiÄ™taÄ‡ miÄ™dzy restartami.
- ObsÅ‚uguje wiele celÃ³w w jednym zdaniu ("wÅ‚Ä…cz Å›wiatÅ‚o 1 i czerwonÄ… diodÄ™").
- Aliasowanie, dopasowanie rozmyte (fuzzy), aliasy zbiorÃ³w ("wszystkie Å›wiatÅ‚a").
- Posiada stan urzÄ…dzeÅ„ (on/off/unknown) i na tej podstawie potrafi NIE pytaÄ‡ bez sensu.

UWAGA: UsuniÄ™to niebezpieczne fallbacki:
- brak automatycznego uÅ¼ycia last_action, jeÅ›li w wejÅ›ciu nie ma sÅ‚Ã³w akcji,
- brak automatycznego uÅ¼ycia last_targets, jeÅ›li nie padÅ‚o â€žto samo/powtÃ³rzâ€.
"""

from __future__ import annotations
import os
import json
import re
import difflib
import subprocess
from pathlib import Path
from typing import Optional, Dict, List, Tuple

try:
    from modules.bus import BUS
except Exception:
    BUS = None

# ÅšcieÅ¼ki
DEFAULT_CONFIG = "/home/hal/HALbridge/device_commands.json"
STATE_DIR = Path("~/.local/share/halbridge").expanduser()
STATE_DIR.mkdir(parents=True, exist_ok=True)
STATE_PATH = STATE_DIR / "hw_context.json"


def _slug(s: str) -> str:
    return re.sub(r"\s+", " ", (s or "").strip().lower())


def _split_targets(text: str) -> List[str]:
    # rozbij po spÃ³jnikach i przecinkach
    parts = re.split(r"\s*(?:,| i | oraz )\s*", text, flags=re.IGNORECASE)
    return [p.strip() for p in parts if p.strip()]


class HardwareBridge:
    def __init__(self, config_path: str = DEFAULT_CONFIG):
        self.config_path = Path(config_path)
        self.commands: Dict[str, Dict[str, str]] = self._load_commands()
        self.aliases: Dict[str, List[str] | str] = self._default_aliases()

        # kontekst / stan w RAM
        self.last_action: Optional[str] = None     # "wÅ‚Ä…cz" / "wyÅ‚Ä…cz"
        self.last_targets: List[str] = []

        # stan urzÄ…dzeÅ„: "on" / "off" / "unknown"
        self.state: Dict[str, str] = {k: "unknown" for k in self.commands.keys()}

        # wczytaj kontekst z dysku (jeÅ›li jest)
        self._load_context()

    # ================== I/O: config + kontekst ==================

    def _load_commands(self) -> Dict[str, Dict[str, str]]:
        if not self.config_path.exists():
            print(f"âš ï¸ Brak pliku {self.config_path}, moduÅ‚ sprzÄ™towy nieaktywny.")
            return {}
        try:
            with open(self.config_path, "r", encoding="utf-8") as f:
                data = json.load(f)
                # normalizuj klucze urzÄ…dzeÅ„
                fixed = {}
                for k, v in (data or {}).items():
                    fixed[_slug(k)] = v
                return fixed
        except Exception as e:
            print(f"âŒ BÅ‚Ä…d Å‚adowania device_commands.json: {e}")
            return {}

    def reload(self):
        """PrzeÅ‚aduj device_commands.json bez restartu."""
        self.commands = self._load_commands()
        # po przeÅ‚adowaniu odÅ›wieÅ¼ rÃ³wnieÅ¼ stan dla nowych/zmienionych urzÄ…dzeÅ„
        for k in self.commands.keys():
            self.state.setdefault(k, "unknown")

    def _save_context(self):
        try:
            with open(STATE_PATH, "w", encoding="utf-8") as f:
                json.dump(
                    {
                        "last_action": self.last_action,
                        "last_targets": self.last_targets,
                        "state": self.state,
                    },
                    f,
                    ensure_ascii=False,
                    indent=2,
                )
        except Exception as e:
            print(f"âš ï¸ Nie zapisano kontekstu: {e}")

    def _load_context(self):
        try:
            if STATE_PATH.exists():
                with open(STATE_PATH, "r", encoding="utf-8") as fh:
                    obj = json.load(fh)
                self.last_action = obj.get("last_action")
                self.last_targets = obj.get("last_targets", []) or []
                loaded_state = obj.get("state", {}) or {}
                # scal stan z aktualnÄ… listÄ… urzÄ…dzeÅ„
                for k in self.commands.keys():
                    if k in loaded_state:
                        self.state[k] = loaded_state[k]
                    else:
                        self.state.setdefault(k, "unknown")
        except Exception as e:
            print(f"âš ï¸ Nie odczytano kontekstu: {e}")

    # ================== Aliasowanie i sÅ‚owniki ==================

    def _default_aliases(self) -> Dict[str, List[str] | str]:
        # dynamiczne zbiory bazujÄ…ce na device_commands.json
        def all_matching(substr: str) -> List[str]:
            key = _slug(substr)
            return [k for k in self.commands.keys() if key in k]

        # statyczne aliasy
        base: Dict[str, List[str] | str] = {
            # ÅšwiatÅ‚a
            "pierwsze Å›wiatÅ‚o": "Å›wiatÅ‚o 1",
            "Å›wiatÅ‚o numer jeden": "Å›wiatÅ‚o 1",
            "drugie Å›wiatÅ‚o": "Å›wiatÅ‚o 2",
            "Å›wiatÅ‚o numer dwa": "Å›wiatÅ‚o 2",
            "pierwsza lampa": "Å›wiatÅ‚o 1",
            "druga lampa": "Å›wiatÅ‚o 2",
            # Diodki / LED
            "zielone": "zielona dioda",
            "czerwone": "czerwona dioda",
            "dioda zielona": "zielona dioda",
            "dioda czerwona": "czerwona dioda",
        }

        # aliasy zbiorÃ³w (odkomentuj, jeÅ›li chcesz)
        base["wszystkie Å›wiatÅ‚a"] = all_matching("Å›wiatÅ‚o")
        base["oba Å›wiatÅ‚a"] = all_matching("Å›wiatÅ‚o")
        base["lampy"] = all_matching("Å›wiatÅ‚o")
        base["Å›wiatÅ‚a"] = all_matching("Å›wiatÅ‚o")
        base["wszystkie diody"] = all_matching("dioda")
        base["diody"] = all_matching("dioda")

        # wzglÄ™dne
        if "Å›wiatÅ‚o 1" in self.commands:
            base.setdefault("pierwsze", "Å›wiatÅ‚o 1")
        if "Å›wiatÅ‚o 2" in self.commands:
            base.setdefault("drugie", "Å›wiatÅ‚o 2")

        # normalizacja kluczy
        normalized: Dict[str, List[str] | str] = {}
        for k, v in base.items():
            normalized[_slug(k)] = v
        return normalized

    # ================== Parsowanie akcji i intencji ==================

    def _parse_action(self, text: str) -> Optional[str]:
        """Zwraca 'wÅ‚Ä…cz'/'wyÅ‚Ä…cz' na podstawie sÅ‚Ã³w kluczowych lub toggle/odwrotnie.
        NIE zwraca last_action â€žz automatuâ€ przy braku sÅ‚Ã³w akcji."""
        t = _slug(text)

        # powtÃ³rz / to samo â†’ zachowaj poprzedniÄ… akcjÄ™, jeÅ›li byÅ‚a
        if re.search(r"\b(powtÃ³rz|to samo|ponownie|jeszcze raz)\b", t):
            return self.last_action or None

        # odwrÃ³Ä‡
        if re.search(r"\b(odwrotnie|na odwrÃ³t|przeÅ‚Ä…cz|toggle)\b", t):
            if self.last_action == "wÅ‚Ä…cz":
                return "wyÅ‚Ä…cz"
            if self.last_action == "wyÅ‚Ä…cz":
                return "wÅ‚Ä…cz"
            return None

        on_words = ["wÅ‚Ä…cz", "wlacz", "zaÅ›wieÄ‡", "zaswiec", "uruchom", "odpal"]
        off_words = ["wyÅ‚Ä…cz", "wylacz", "zgaÅ›", "zgas", "zatrzymaj", "wyÅ‚Ä…czyÄ‡"]

        if any(w in t for w in on_words):
            return "wÅ‚Ä…cz"
        if any(w in t for w in off_words):
            return "wyÅ‚Ä…cz"

        # brak sÅ‚Ã³w akcji â†’ brak akcji (nie uÅ¼ywamy last_action w ciemno)
        return None

    def _strip_action_words(self, text: str) -> str:
        t = " " + _slug(text) + " "
        t = re.sub(r"\b(wÅ‚Ä…cz|wlacz|zaÅ›wieÄ‡|zaswiec|uruchom|odpal)\b", " ", t)
        t = re.sub(r"\b(wyÅ‚Ä…cz|wylacz|zgaÅ›|zgas|zatrzymaj|wyÅ‚Ä…czyÄ‡)\b", " ", t)
        t = re.sub(r"\b(powtÃ³rz|to samo|ponownie|jeszcze raz|odwrotnie|na odwrÃ³t|przeÅ‚Ä…cz|toggle)\b", " ", t)
        return re.sub(r"\s+", " ", t).strip()

    # ================== RozwiÄ…zywanie nazw urzÄ…dzeÅ„ ==================

    def _resolve_single(self, name: str) -> List[str]:
        """Zwraca listÄ™ urzÄ…dzeÅ„ po rozwiniÄ™ciu aliasÃ³w i fuzzy."""
        key = _slug(name)
        # alias bezpoÅ›redni
        if key in self.aliases:
            v = self.aliases[key]
            if isinstance(v, list):
                return [_slug(x) for x in v if _slug(x) in self.commands]
            else:
                s = _slug(v)
                return [s] if s in self.commands else []

        # jeÅ›li nazwa wystÄ™puje bezpoÅ›rednio
        if key in self.commands:
            return [key]

        # dopasowania zawierajÄ…ce
        contains = [dev for dev in self.commands if key in dev]
        if contains:
            return contains

        # fuzzy
        match = difflib.get_close_matches(key, list(self.commands.keys()), n=1, cutoff=0.72)
        if match:
            return [match[0]]

        # wzglÄ™dne do last_targets, jeÅ›li uÅ¼yto â€žpierwsze/drugieâ€
        if key in ("pierwsze", "pierwszy") and self.last_targets:
            return [self.last_targets[0]]
        if key in ("drugie", "drugi") and len(self.last_targets) >= 2:
            return [self.last_targets[1]]

        return []

    def _resolve_targets(self, text: str) -> List[str]:
        parts = _split_targets(text)
        targets: List[str] = []
        for p in parts:
            res = self._resolve_single(p)
            targets.extend(res)

        # explicite â€žto samo/powtÃ³rzâ€
        if not targets and re.search(r"\b(to samo|powtÃ³rz|ponownie|jeszcze raz)\b", _slug(text)):
            return list(self.last_targets)

        # unikaty przy zachowaniu kolejnoÅ›ci
        seen = set()
        uniq = []
        for t in targets:
            if t not in seen:
                seen.add(t)
                uniq.append(t)
        return uniq

    # ================== Wykonanie ==================

    def _run(self, cmd: str):
        try:
            subprocess.run(cmd, shell=True, check=False, timeout=10)
        except Exception as e:
            print(f"âŒ BÅ‚Ä…d wykonania komendy: {e}")

    def _exec_for(self, action: str, targets: List[str]) -> Tuple[List[str], List[str]]:
        ok, missing = [], []
        for dev in targets:
            entry = self.commands.get(dev) or {}
            cmd = entry.get(action)
            if not cmd:
                missing.append(dev)
                continue
            print(f"âž¡ï¸ {action.upper()} â†’ {dev}")
            self._run(cmd)
            ok.append(dev)

            # aktualizuj stan urzÄ…dzenia
            if action == "wÅ‚Ä…cz":
                self.state[dev] = "on"
            elif action == "wyÅ‚Ä…cz":
                self.state[dev] = "off"

        return ok, missing

    # ================== Logika wyboru Å›wiatÅ‚a bez numeru ==================

    def resolve_light_without_number(self, raw_text: str) -> Optional[str]:
        """
        ObsÅ‚uguje przypadki:
        - 'wÅ‚Ä…cz Å›wiatÅ‚o'
        - 'wyÅ‚Ä…cz Å›wiatÅ‚o'
        jeÅ›li brak numeru â†’ wybieramy na podstawie STANU (state),
        a jeÅ›li stan niejednoznaczny â†’ pytamy z timeoutem.
        """

        t = _slug(raw_text)

        # rozpoznaj akcjÄ™
        action = self._parse_action(raw_text)
        if not action:
            return None

        # to musi byÄ‡ Å›wiatÅ‚o
        if "Å›wiatÅ‚o" not in t:
            return None

        # jest numer â†’ wszystko OK
        if re.search(r"\b1\b|\b2\b", t):
            return None

        # --- przypadek: WYÅÄ„CZ i tylko jedno Å›wiatÅ‚o jest ON â†’ wybierz je automatycznie ---
        if action == "wyÅ‚Ä…cz":
            on_list = [dev for dev, st in self.state.items() if st == "on"]
            if len(on_list) == 1:
                dev = on_list[0]
                return f"{action} {dev}"

        # --- przypadek: WÅÄ„CZ i tylko jedno Å›wiatÅ‚o jest OFF â†’ moÅ¼na zgadnÄ…Ä‡ ---
        if action == "wÅ‚Ä…cz":
            off_list = [dev for dev, st in self.state.items() if st == "off"]
            if len(off_list) == 1:
                dev = off_list[0]
                return f"{action} {dev}"

        # --- pytamy uÅ¼ytkownika (interaktywnie) ---
        print(f"ðŸ¤” KtÃ³re Å›wiatÅ‚o mam {action}? (1/2)")
        print("(czekam 10 sekund...)")

        import select, sys
        r, w, e = select.select([sys.stdin], [], [], 10)

        if r:
            ans = sys.stdin.readline().strip()
            if ans == "1":
                return f"{action} Å›wiatÅ‚o 1"
            if ans == "2":
                return f"{action} Å›wiatÅ‚o 2"
            print(f"âš ï¸ Nie rozumiem, {action} oba.")
            return f"{action} Å›wiatÅ‚o 1 i Å›wiatÅ‚o 2"
        else:
            print(f"âŒ› Czas minÄ…Å‚ â€” {action} oba Å›wiatÅ‚a.")
            return f"{action} Å›wiatÅ‚o 1 i Å›wiatÅ‚o 2"

    # ================== Public API ==================

    def execute(self, text: str) -> Optional[str]:
        """
        Analizuje tekst (np. 'wÅ‚Ä…cz Å›wiatÅ‚o 2') i uruchamia odpowiednie polecenia z device_commands.json.
        Zwraca wynik tekstowy lub None, jeÅ›li brak dopasowania.
        """
        if not text or not self.commands:
            return None

        raw = text

        # --- logika: Å›wiatÅ‚o bez numeru (korzystajÄ…ca ze stanu) ---
        modified = self.resolve_light_without_number(raw)
        if modified:
            raw = modified

        action = self._parse_action(raw)
        targets_text = self._strip_action_words(raw)
        targets = self._resolve_targets(targets_text)

        # Bez akcji i bez targetÃ³w â†’ brak intencji
        if not action and not targets:
            return None

        # JeÅ›li nie ma akcji â†’ nie zgadujemy â€žostatniejâ€, przerywamy
        if not action:
            return None

        # JeÅ›li nie ma targetÃ³w â†’ nie zgadujemy â€žostatnichâ€, przerywamy
        if not targets:
            return None

        ok, missing = self._exec_for(action, targets)

        # aktualizuj kontekst tylko po realnym wykonaniu
        if ok:
            self.last_action = action
            self.last_targets = ok
            self._save_context()

        msg = []
        if ok:
            msg.append(f"âœ… {action} wykonano dla: {', '.join(ok)}")
        if missing:
            msg.append(f"âš ï¸ Brak komendy '{action}' dla: {', '.join(missing)}")
        return " | ".join(msg) if msg else None


# ====== Test lokalny (rÄ™czny) ======
if __name__ == "__main__":
    hb = HardwareBridge()
    print("HALbridge Hardware Bridge â€” tryb testowy. Pusta linia koÅ„czy.")
    try:
        while True:
            t = input("> ").strip()
            if not t:
                break
            print(hb.execute(t) or "âˆ… brak akcji/targetÃ³w")
    except KeyboardInterrupt:
        print("\nâˆŽ")
